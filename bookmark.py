#!/usr/bin/env python3
"""
Directory Bookmark Manager v2.0
Saves and manages directory bookmarks in ~/.dir-bookmarks.txt

Author: Hasin Hayder
Repository: https://github.com/hasinhayder/bookomark.py
Version: 2.0
License: MIT
"""

import os
import sys
import subprocess
import json
import platform
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Union


class BookmarkManager:
    def __init__(self):
        self.bookmark_file = Path.home() / ".dir-bookmarks.txt"
        self.current_dir = os.getcwd()
        self.platform = platform.system().lower()

    def load_bookmarks(self) -> Dict[str, str]:
        """Load existing bookmarks from file.
        
        Returns:
            Dict[str, str]: Dictionary mapping paths to bookmark names
        """
        bookmarks = {}
        if self.bookmark_file.exists():
            try:
                with open(self.bookmark_file, "r", encoding="utf-8") as f:
                    for line_num, line in enumerate(f, 1):
                        line = line.strip()
                        if not line or "|" not in line:
                            continue
                        
                        # Validate line format
                        if line.count("|") != 1:
                            print(f"Warning: Skipping invalid line {line_num} in bookmarks file", file=sys.stderr)
                            continue
                            
                        name, path = line.split("|", 1)
                        if name.strip() and path.strip():
                            bookmarks[path.strip()] = name.strip()
                        else:
                            print(f"Warning: Skipping empty name or path on line {line_num}", file=sys.stderr)
            except PermissionError:
                print(f"Error: Permission denied reading {self.bookmark_file}", file=sys.stderr)
            except UnicodeDecodeError as e:
                print(f"Error: File encoding issue in {self.bookmark_file}: {e}", file=sys.stderr)
            except Exception as e:
                print(f"Error reading bookmarks: {e}", file=sys.stderr)
        return bookmarks

    def save_bookmarks(self, bookmarks: Dict[str, str]) -> bool:
        """Save bookmarks to file.
        
        Args:
            bookmarks: Dictionary mapping paths to bookmark names
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Create parent directory if it doesn't exist
            self.bookmark_file.parent.mkdir(parents=True, exist_ok=True)
            
            with open(self.bookmark_file, "w", encoding="utf-8") as f:
                # Write header comment
                f.write("# Directory Bookmarks - Format: name|path\n")
                f.write(f"# Generated by Bookmark Manager v2.0 on {platform.node()}\n")
                f.write("\n")
                
                # Sort bookmarks by name for consistent output
                for path, name in sorted(bookmarks.items(), key=lambda x: x[1].lower()):
                    f.write(f"{name}|{path}\n")
                    
            return True
        except PermissionError:
            print(f"Error: Permission denied writing to {self.bookmark_file}", file=sys.stderr)
            return False
        except Exception as e:
            print(f"Error saving bookmarks: {e}", file=sys.stderr)
            return False

    def add_bookmark(self) -> None:
        """Add current directory as bookmark with interactive input."""
        bookmarks = self.load_bookmarks()

        # Check if current directory is already bookmarked
        if self.current_dir in bookmarks:
            print(
                f"Directory '{self.current_dir}' is already bookmarked as '{bookmarks[self.current_dir]}'",
                file=sys.stderr,
            )
            return

        # Ask for friendly name with validation
        friendly_name = self._get_valid_name("Enter a friendly name for this directory: ")
        if not friendly_name:
            return

        # Check if friendly name already exists
        existing_names = set(bookmarks.values())
        if friendly_name in existing_names:
            print(f"A bookmark with the name '{friendly_name}' already exists.", file=sys.stderr)
            overwrite = input("Do you want to overwrite it? (y/N): ").strip().lower()
            if overwrite != "y":
                print("Bookmark not saved.", file=sys.stderr)
                return
            # Remove existing bookmark with same name
            bookmarks = {
                path: name for path, name in bookmarks.items() if name != friendly_name
            }

        # Add new bookmark
        bookmarks[self.current_dir] = friendly_name

        if self.save_bookmarks(bookmarks):
            print(f"Bookmark '{friendly_name}' saved for '{self.current_dir}'", file=sys.stderr)
        else:
            print("Failed to save bookmark.", file=sys.stderr)

    def remove_bookmark(self) -> None:
        """Remove bookmark for current directory."""
        bookmarks = self.load_bookmarks()

        if self.current_dir not in bookmarks:
            print(f"No bookmark found for current directory: {self.current_dir}", file=sys.stderr)
            return

        bookmark_name = bookmarks[self.current_dir]
        del bookmarks[self.current_dir]

        if self.save_bookmarks(bookmarks):
            print(f"Bookmark '{bookmark_name}' removed for '{self.current_dir}'", file=sys.stderr)
        else:
            print("Failed to remove bookmark.", file=sys.stderr)

    def _get_sorted_bookmark_list(self) -> List[Tuple[str, str]]:
        """Get sorted list of bookmarks as (name, path) tuples.
        
        Returns:
            List[Tuple[str, str]]: Sorted list of (name, path) tuples
        """
        bookmarks = self.load_bookmarks()
        bookmark_list = [(name, path) for path, name in bookmarks.items()]
        bookmark_list.sort(key=lambda x: x[0].lower())
        return bookmark_list

    def _check_bookmarks_exist(self) -> bool:
        """Check if bookmarks exist and show message if empty.
        
        Returns:
            bool: True if bookmarks exist, False otherwise
        """
        bookmarks = self.load_bookmarks()
        if not bookmarks:
            print("No bookmarks found.", file=sys.stderr)
            print("Use 'bookmark' command to create bookmarks.", file=sys.stderr)
            return False
        return True

    def _display_bookmark_menu(
        self, title: str = "Bookmarked directories", width: int = 40, show_lowercase: bool = True
    ) -> List[Tuple[str, str]]:
        """Display bookmarks menu with numbers.
        
        Args:
            title: Title to display above the menu
            width: Width of the separator line
            show_lowercase: Whether to display names in lowercase
            
        Returns:
            List[Tuple[str, str]]: List of (name, path) tuples
        """
        bookmark_list = self._get_sorted_bookmark_list()

        print(f"{title}:", file=sys.stderr)
        print("-" * width, file=sys.stderr)
        for i, (name, path) in enumerate(bookmark_list, 1):
            display_name = name.lower() if show_lowercase else name
            print(f"{i:2d}. {display_name}", file=sys.stderr)
        print("-" * width, file=sys.stderr)
        return bookmark_list

    def _get_user_selection(
        self, bookmark_list: List[Tuple[str, str]], 
        prompt: str = "Select a directory (number) or 0 to exit: "
    ) -> Optional[Union[str, Tuple[str, str]]]:
        """Get user selection from bookmark list.
        
        Args:
            bookmark_list: List of (name, path) tuples
            prompt: Prompt message to display
            
        Returns:
            Optional[Union[str, Tuple[str, str]]]: Selected path, "EXIT", or None
        """
        try:
            print(prompt, end="", file=sys.stderr)
            sys.stderr.flush()

            choice = sys.stdin.readline().strip()
            choice_num = int(choice)

            if choice_num == 0:
                print("Exiting...", file=sys.stderr)
                return "EXIT"
            elif 1 <= choice_num <= len(bookmark_list):
                return bookmark_list[choice_num - 1][1]  # Return path
            else:
                print(
                    f"Invalid selection. Please choose 0-{len(bookmark_list)}",
                    file=sys.stderr,
                )
                return None
        except ValueError:
            print("Invalid input. Please enter a number.", file=sys.stderr)
            return None
        except KeyboardInterrupt:
            print("\nCancelled.", file=sys.stderr)
            return None
        except EOFError:
            print("\nCancelled.", file=sys.stderr)
            return None

    def list_bookmarks(self) -> None:
        """List all bookmarks and allow selection by number."""
        if not self._check_bookmarks_exist():
            return

        bookmark_list = self._display_bookmark_menu()
        selected_path = self._get_user_selection(bookmark_list)

        if selected_path and selected_path != "EXIT":
            print(selected_path)

    def open_bookmark(self) -> None:
        """List all bookmarks, allow selection, and open in file manager."""
        if not self._check_bookmarks_exist():
            return

        bookmark_list = self._display_bookmark_menu()
        selected_path = self._get_user_selection(
            bookmark_list, "Select a directory to open (number) or 0 to exit: "
        )

        if selected_path and selected_path != "EXIT":
            # Check if directory exists
            if not os.path.exists(selected_path):
                print(f"Directory not found: {selected_path}", file=sys.stderr)
                return

            # Echo the directory path
            print(selected_path)

            # Open in file manager based on platform
            if self.platform == "darwin":  # macOS
                self._run_command(
                    ["open", selected_path],
                    f"Opened '{selected_path}' in Finder",
                    "Failed to open directory in Finder",
                    "'open' command not found. This feature requires macOS.",
                )
            elif self.platform == "linux":  # Linux
                self._run_command(
                    ["xdg-open", selected_path],
                    f"Opened '{selected_path}' in file manager",
                    "Failed to open directory in file manager",
                    "'xdg-open' command not found. This feature requires a desktop environment.",
                )
            elif self.platform == "windows":  # Windows
                self._run_command(
                    ["explorer", selected_path.replace("/", "\\")],
                    f"Opened '{selected_path}' in File Explorer",
                    "Failed to open directory in File Explorer",
                    "This feature requires Windows.",
                )
            else:
                print(f"Platform '{self.platform}' not supported for opening directories.", file=sys.stderr)

    def _run_command(self, command: List[str], success_msg: str, error_msg_prefix: str, not_found_msg: str) -> bool:
        """Run a subprocess command with error handling.
        
        Args:
            command: Command to run as a list
            success_msg: Message to print on success
            error_msg_prefix: Prefix for error messages
            not_found_msg: Message when command is not found
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            result = subprocess.run(command, check=True, capture_output=True, text=True)
            print(success_msg, file=sys.stderr)
            return True
        except subprocess.CalledProcessError as e:
            print(f"{error_msg_prefix}: {e}", file=sys.stderr)
            if e.stderr:
                print(f"Error output: {e.stderr.strip()}", file=sys.stderr)
            return False
        except FileNotFoundError:
            print(not_found_msg, file=sys.stderr)
            return False

    def debug_bookmarks(self) -> None:
        """Open the bookmarks file in VS Code for debugging."""
        # Try VS Code first, then fallback to other editors
        editors = [
            (["code", str(self.bookmark_file)], "VS Code"),
            (["vim", str(self.bookmark_file)], "Vim"),
            (["nano", str(self.bookmark_file)], "Nano"),
            (["cat", str(self.bookmark_file)], "Cat (read-only)"),
        ]
        
        for command, editor_name in editors:
            if self._run_command(
                command,
                f"Opened '{self.bookmark_file}' in {editor_name}",
                f"Failed to open file in {editor_name}",
                f"'{command[0]}' command not found. Please ensure {editor_name} is installed.",
            ):
                return
                
        print("No suitable editor found. You can manually edit:", file=sys.stderr)
        print(f"  {self.bookmark_file}", file=sys.stderr)

    def flush_bookmarks(self) -> None:
        """Clear all bookmarks from the file."""
        if not self.bookmark_file.exists():
            print("No bookmarks file found to clear.", file=sys.stderr)
            return
            
        # Show current count before clearing
        bookmarks = self.load_bookmarks()
        count = len(bookmarks)
        
        if count == 0:
            print("No bookmarks to clear.", file=sys.stderr)
            return
            
        print(f"Current bookmarks: {count}", file=sys.stderr)
        confirm = input(f"Are you sure you want to delete all {count} bookmarks? (type 'yes' to confirm): ").strip()
        
        if confirm.lower() == "yes":
            try:
                # Create a backup before clearing
                import datetime
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_file = Path.home() / f".dir-bookmarks-before-flush-{timestamp}.txt"
                
                if bookmarks:
                    import shutil
                    shutil.copy2(self.bookmark_file, backup_file)
                    print(f"Backup created: {backup_file}", file=sys.stderr)
                
                # Clear the file
                with open(self.bookmark_file, "w", encoding="utf-8") as f:
                    f.write("# Directory Bookmarks - Cleared\n")
                    f.write(f"# Backup available at: {backup_file}\n")
                    
                print("All bookmarks have been cleared.", file=sys.stderr)
            except Exception as e:
                print(f"Error clearing bookmarks: {e}", file=sys.stderr)
        else:
            print("Operation cancelled.", file=sys.stderr)

    def listall_bookmarks(self) -> None:
        """List all bookmarks with their full paths."""
        if not self._check_bookmarks_exist():
            return

        bookmark_list = self._get_sorted_bookmark_list()

        # Display all bookmarks with their paths
        print("All bookmarked directories:", file=sys.stderr)
        print("-" * 60, file=sys.stderr)
        for i, (name, path) in enumerate(bookmark_list, 1):
            print(f"{i:2d}. {name} -> {path}", file=sys.stderr)
        print("-" * 60, file=sys.stderr)
        print(f"Total: {len(bookmark_list)} bookmark(s)", file=sys.stderr)

    def show_help(self) -> None:
        """Display comprehensive help information."""
        help_text = """
Directory Bookmark Manager v2.0
===============================
Author: Hasin Hayder
Repository: https://github.com/hasinhayder/bookomark.py

USAGE:
    bookmark [OPTION]

OPTIONS:
    (no option)     Add current directory as bookmark
                    - Prompts for a friendly name
                    - Prevents duplicate directories and names
                    - Saves to ~/.dir-bookmarks.txt

    --remove        Remove bookmark for current directory
                    - Deletes the bookmark for the current working directory
                    - Shows confirmation message

    --list          List bookmarks and select one
                    - Shows bookmarks in lowercase, sorted alphabetically
                    - Prompts for number selection
                    - Outputs selected directory path (useful for scripting)

    --open          List bookmarks and open selected directory in file manager
                    - Same interface as --list
                    - Opens selected directory in platform file manager
                    - Supports macOS (Finder), Linux (xdg-open), Windows (Explorer)

    --go            Navigate to bookmarked directory
                    - Shows bookmarks in lowercase, sorted alphabetically
                    - Prompts for number selection
                    - Outputs selected directory path for shell navigation
                    - Used by goto shell function

    --listall       Display all bookmarks with their full paths
                    - Shows name -> path mapping
                    - Includes total count
                    - No selection required

    --debug         Open bookmarks file in text editor
                    - Opens ~/.dir-bookmarks.txt in available editor
                    - Tries VS Code, Vim, Nano, or Cat in that order
                    - For manual editing and debugging

    --flush         Clear all bookmarks permanently
                    - Deletes all bookmarks from the file
                    - Creates backup before clearing
                    - Requires confirmation
                    - Use with caution - this action cannot be undone

    --backup        Create a timestamped backup of bookmarks
                    - Saves current bookmarks to ~/.dir-bookmarks-backup-YYYYMMDD_HHMMSS.txt
                    - Shows count of backed up bookmarks
                    - Safe operation - doesn't modify existing bookmarks

    --restore       Restore bookmarks from a backup file
                    - Lists available backup files with timestamps and bookmark counts
                    - Prompts for backup selection
                    - Creates backup of current bookmarks before restore
                    - Confirms before overwriting current bookmarks

    --help          Show this help message

EXAMPLES:
    bookmark                    # Add current directory as bookmark
    bookmark --remove           # Remove current directory's bookmark
    bookmark --list             # List and select bookmark (outputs path)
    bookmark --open             # List and open bookmark in file manager
    bookmark --listall          # Show all bookmarks with paths
    bookmark --debug            # Edit bookmarks file in text editor
    bookmark --flush            # Clear all bookmarks
    bookmark --backup           # Create timestamped backup of bookmarks
    bookmark --restore          # Restore bookmarks from backup
    bookmark --help             # Show this help
    goto                        # Navigate to bookmarked directory (shell function)

RELATED COMMANDS:
    goto                        # Navigate to bookmarked directory (shell function)
                                # Uses 'bookmark --go' internally

FILES:
    ~/.dir-bookmarks.txt        # Bookmark storage file

NOTES:
    - Bookmarks are stored as: friendly_name|/full/path/to/directory
    - Directory names are displayed in lowercase but stored with original case
    - Duplicate directory paths and friendly names are prevented
    - The --open feature supports multiple platforms (macOS, Linux, Windows)
    - The --debug feature tries multiple editors automatically
    - All operations include proper error handling and user feedback
"""
        print(help_text.strip())

    def show_info(self) -> None:
        """Display author and repository information."""
        info_text = """
Directory Bookmark Manager v2.0
===============================
Author: Hasin Hayder
Repository: https://github.com/hasinhayder/bookomark.py
License: MIT
Platform: Cross-platform (macOS, Linux, Windows)
"""
        print(info_text.strip())

    def go_bookmark(self) -> None:
        """Navigate to bookmarked directory (same as goto.py functionality)."""
        if not self._check_bookmarks_exist():
            return

        bookmark_list = self._display_bookmark_menu()
        selected_path = self._get_user_selection(bookmark_list)

        if selected_path and selected_path != "EXIT":
            print(selected_path)

    def backup_bookmarks(self) -> None:
        """Create a backup of current bookmarks."""
        if not self.bookmark_file.exists():
            print("No bookmarks file found to backup.", file=sys.stderr)
            return

        # Get timestamp for backup filename
        import datetime

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = Path.home() / f".dir-bookmarks-backup-{timestamp}.txt"

        try:
            # Copy bookmarks file to backup
            import shutil

            shutil.copy2(self.bookmark_file, backup_file)
            print(f"Bookmarks backed up to: {backup_file}", file=sys.stderr)

            # Also show current bookmark count
            bookmarks = self.load_bookmarks()
            print(f"Backed up {len(bookmarks)} bookmark(s)", file=sys.stderr)

        except PermissionError:
            print(f"Error: Permission denied creating backup at {backup_file}", file=sys.stderr)
        except Exception as e:
            print(f"Error creating backup: {e}", file=sys.stderr)

    def restore_bookmarks(self) -> None:
        """Restore bookmarks from a backup file."""
        backup_dir = Path.home()
        backup_files = list(backup_dir.glob(".dir-bookmarks-backup-*.txt"))

        if not backup_files:
            print("No backup files found.", file=sys.stderr)
            print(
                "Backup files should be named: ~/.dir-bookmarks-backup-YYYYMMDD_HHMMSS.txt",
                file=sys.stderr,
            )
            return

        # Sort backup files by modification time (newest first)
        backup_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)

        print("Available backup files:", file=sys.stderr)
        print("-" * 50, file=sys.stderr)

        for i, backup_file in enumerate(backup_files, 1):
            # Extract timestamp from filename
            filename = backup_file.name
            timestamp_part = filename.replace(".dir-bookmarks-backup-", "").replace(
                ".txt", ""
            )

            try:
                # Parse timestamp for display
                from datetime import datetime

                dt = datetime.strptime(timestamp_part, "%Y%m%d_%H%M%S")
                formatted_date = dt.strftime("%Y-%m-%d %H:%M:%S")

                # Count bookmarks in backup file
                backup_count = 0
                try:
                    with open(backup_file, "r", encoding="utf-8") as f:
                        backup_count = sum(
                            1 for line in f if line.strip() and "|" in line and not line.strip().startswith("#")
                        )
                except:
                    backup_count = "?"

                print(
                    f"{i:2d}. {formatted_date} ({backup_count} bookmarks)",
                    file=sys.stderr,
                )

            except ValueError:
                # If timestamp parsing fails, just show filename
                print(f"{i:2d}. {filename}", file=sys.stderr)

        print("-" * 50, file=sys.stderr)

        # Get user selection
        try:
            print("Select backup to restore (number): ", end="", file=sys.stderr)
            sys.stderr.flush()

            choice = sys.stdin.readline().strip()
            choice_num = int(choice)

            if 1 <= choice_num <= len(backup_files):
                selected_backup = backup_files[choice_num - 1]

                # Show current bookmarks count before restore
                current_bookmarks = self.load_bookmarks()
                current_count = len(current_bookmarks)

                # Confirm restore operation
                print(
                    f"This will replace your current {current_count} bookmark(s).",
                    file=sys.stderr,
                )
                confirm = (
                    input("Are you sure you want to restore? (y/N): ").strip().lower()
                )

                if confirm == "y":
                    try:
                        import shutil
                        import datetime

                        # Create backup of current file before restore
                        if self.bookmark_file.exists():
                            current_backup = (
                                Path.home()
                                / f".dir-bookmarks-before-restore-{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
                            )
                            shutil.copy2(self.bookmark_file, current_backup)
                            print(
                                f"Current bookmarks backed up to: {current_backup}",
                                file=sys.stderr,
                            )

                        # Restore from selected backup
                        shutil.copy2(selected_backup, self.bookmark_file)

                        # Verify restore
                        restored_bookmarks = self.load_bookmarks()
                        print(
                            f"Successfully restored {len(restored_bookmarks)} bookmark(s) from backup.",
                            file=sys.stderr,
                        )

                    except PermissionError:
                        print(f"Error: Permission denied restoring from {selected_backup}", file=sys.stderr)
                    except Exception as e:
                        print(f"Error restoring backup: {e}", file=sys.stderr)
                else:
                    print("Restore cancelled.", file=sys.stderr)
            else:
                print(
                    f"Invalid selection. Please choose 1-{len(backup_files)}",
                    file=sys.stderr,
                )

        except ValueError:
            print("Invalid input. Please enter a number.", file=sys.stderr)
        except KeyboardInterrupt:
            print("\nCancelled.", file=sys.stderr)
        except EOFError:
            print("\nCancelled.", file=sys.stderr)


def _get_valid_name(self, prompt: str) -> Optional[str]:
        """Get a valid bookmark name from user input.
        
        Args:
            prompt: Prompt message to display
            
        Returns:
            Optional[str]: Validated bookmark name or None if cancelled
        """
        while True:
            try:
                friendly_name = input(prompt).strip()
                if not friendly_name:
                    print("Please enter a valid name.", file=sys.stderr)
                    continue
                
                # Basic validation
                if len(friendly_name) > 100:
                    print("Name too long. Please use a shorter name.", file=sys.stderr)
                    continue
                
                # Check for invalid characters for file paths
                invalid_chars = ['<', '>', ':', '"', '|', '?', '*']
                if any(char in friendly_name for char in invalid_chars):
                    print("Name contains invalid characters. Please use a different name.", file=sys.stderr)
                    continue
                
                return friendly_name
                
            except (KeyboardInterrupt, EOFError):
                print("\nCancelled.", file=sys.stderr)
                return None


def main() -> None:
    """Main entry point for the bookmark manager."""
    try:
        manager = BookmarkManager()

        # Command mapping for cleaner main function
        commands = {
            "--remove": manager.remove_bookmark,
            "--list": manager.list_bookmarks,
            "--open": manager.open_bookmark,
            "--go": manager.go_bookmark,
            "--debug": manager.debug_bookmarks,
            "--flush": manager.flush_bookmarks,
            "--listall": manager.listall_bookmarks,
            "--backup": manager.backup_bookmarks,
            "--restore": manager.restore_bookmarks,
            "--help": manager.show_help,
            "--version": manager.show_info,
            "--info": manager.show_info,  # Alias for --version
        }

        if len(sys.argv) > 1:
            command = sys.argv[1]
            if command in commands:
                commands[command]()
            else:
                print(f"Unknown option: {command}", file=sys.stderr)
                print(
                    "Usage: bookmark [--remove|--list|--open|--go|--debug|--flush|--listall|--backup|--restore|--help]",
                    file=sys.stderr,
                )
                sys.exit(1)
        else:
            # Add bookmark mode (default)
            manager.add_bookmark()
            
    except KeyboardInterrupt:
        print("\nOperation cancelled.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
